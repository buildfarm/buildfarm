#!/bin/bash

set -e
# This is a drop-in replacement for cgexec, with the following differences:
#
# - It will put child processes in a cgroup relative to THIS cgroup's parent.

# Required arguments:
# -g <controllers>:<CgroupName>

# Function to display usage information
usage() {
    echo "Usage: $0 -g <value>" >&2
    exit 1
}

# Parse command line arguments
while getopts ":g:" opt; do
  case ${opt} in
    g )
      # Split the value on ":" and assign to variables
      IFS=':' read -r -a parts <<< "$OPTARG"
      controllers="${parts[0]}"
      cgroupName="${parts[1]}"
      ;;
    \? )
      usage
      ;;
  esac
done
shift $((OPTIND -1))

# Check if both variables are set, otherwise show an error message and exit
if [ -z "$controllers" ] || [ -z "$cgroupName" ]; then
    echo "Error: Both controllers and cgroupName must be specified." >&2
    usage
fi

# Get my own Cgroup from /proc/self/cgroup.
# There are three fields here, separated by ':':
# - the group ID. This is always 0 for cgroups v2.
# - the enabled controllers. This is always empty for cgroups v2.
# - the cgroup Path. This is the only part we care about.
cgroupNameRelativePath="$(cut -d':' -f3- < /proc/self/cgroup)"

# Debug output (can be disabled by setting CGEXEC_DEBUG=0)
if [ "${CGEXEC_DEBUG:-1}" = "1" ]; then
    echo "Debug: cgroupNameRelativePath=$cgroupNameRelativePath" >&2
    echo "Debug: controllers=$controllers" >&2
    echo "Debug: cgroupName=$cgroupName" >&2
fi

# This diverges from `cgexec` where we place ourselves in a group relative to parent.
# Example:
# cgroupName = `executions/operations/29aec796-ad19-4e6b-a83b-b8b9f55d0abb`
# This process starts in the ${cgroupNameRelativePath} cgroup:
#   ├─${baseCgroup}
#   │ ├─${cgroupNameRelativePath}
#   │ │ ├─123456 /tini -- java -jar /app/build_buildfarm/buildfarm-shard-worker_deploy.jar
#   │ │ └─123457 java -jar /app/build_buildfarm/buildfarm-shard-worker_deploy.jar
#   │ └─executions
#   │   └─operations
#   │     └─29aec796-ad19-4e6b-a83b-b8b9f55d0abb
#   │        └─123458 ${@}
baseCgroup=$(dirname "${cgroupNameRelativePath}")

# More debug output
if [ "${CGEXEC_DEBUG:-1}" = "1" ]; then
    echo "Debug: baseCgroup=$baseCgroup" >&2
    echo "Debug: target_cgroup=/sys/fs/cgroup${baseCgroup}/$cgroupName" >&2
fi
# Bouncing my own PID $$ into /sys/fs/cgroup${baseCgroup}/$cgroupName"
target_cgroup="/sys/fs/cgroup${baseCgroup}/$cgroupName"

# Check if the cgroup directory exists
if [ ! -d "$target_cgroup" ]; then
    echo "Error: Cgroup directory does not exist: $target_cgroup" >&2
    echo "Available cgroups in ${baseCgroup}:" >&2
    ls -la "/sys/fs/cgroup${baseCgroup}/" 2>/dev/null || echo "Base cgroup directory not accessible: /sys/fs/cgroup${baseCgroup}/" >&2
    
    # Attempt to create the cgroup directory if parent exists
    parent_cgroup="/sys/fs/cgroup${baseCgroup}"
    if [ -d "$parent_cgroup" ] && [ -w "$parent_cgroup" ]; then
        echo "Attempting to create cgroup directory: $target_cgroup" >&2
        if mkdir -p "$target_cgroup" 2>/dev/null; then
            echo "Successfully created cgroup directory: $target_cgroup" >&2
        else
            echo "Failed to create cgroup directory: $target_cgroup" >&2
            exit 1
        fi
    else
        exit 1
    fi
fi

# Check if cgroup.procs file exists and is writable
if [ ! -f "$target_cgroup/cgroup.procs" ]; then
    echo "Error: cgroup.procs file does not exist: $target_cgroup/cgroup.procs" >&2
    exit 1
fi

if [ ! -w "$target_cgroup/cgroup.procs" ]; then
    echo "Error: No write permission to: $target_cgroup/cgroup.procs" >&2
    echo "Current user: $(id)" >&2
    echo "File permissions: $(ls -la "$target_cgroup/cgroup.procs" 2>/dev/null || echo "File not accessible")" >&2
    exit 1
fi

# Attempt to write PID to cgroup.procs with error handling
if ! echo $$ > "$target_cgroup/cgroup.procs" 2>/dev/null; then
    echo "Error: Failed to write PID $$ to $target_cgroup/cgroup.procs" >&2
    echo "This may be due to:"
    echo "  - Insufficient permissions (try running with appropriate privileges)"
    echo "  - Cgroup is frozen or in an invalid state"
    echo "  - Process already belongs to an incompatible cgroup"
    echo "Current process cgroup: $cgroupNameRelativePath" >&2
    echo "Target cgroup: $target_cgroup" >&2
    exit 1
fi

# Exec the rest of the arguments as-is
exec "$@"
