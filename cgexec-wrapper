#!/bin/bash

set -e
# This is a drop-in replacement for cgexec, with the following differences:
#
# - It will put child processes in a cgroup relative to THIS cgroup's parent.

# Required arguments:
# -g <controllers>:<CgroupName>

# Function to display usage information
usage() {
    echo "Usage: $0 -g <value>" >&2
    exit 1
}

# Parse command line arguments
while getopts ":g:" opt; do
  case ${opt} in
    g )
      # Split the value on ":" and assign to variables
      IFS=':' read -r -a parts <<< "$OPTARG"
      controllers="${parts[0]}"
      cgroupName="${parts[1]}"
      ;;
    \? )
      usage
      ;;
  esac
done
shift $((OPTIND -1))

# Check if both variables are set, otherwise show an error message and exit
if [ -z "$controllers" ] || [ -z "$cgroupName" ]; then
    echo "Error: Both controllers and cgroupName must be specified." >&2
    usage
fi

# Get my own Cgroup from /proc/self/cgroup.
# There are three fields here, separated by ':':
# - the group ID. This is always 0 for cgroups v2.
# - the enabled controllers. This is always empty for cgroups v2.
# - the cgroup Path. This is the only part we care about.
cgroupNameRelativePath="$(cut -d':' -f3- < /proc/self/cgroup)"

# Debug output (can be disabled by setting CGEXEC_DEBUG=0)
if [ "${CGEXEC_DEBUG:-1}" = "1" ]; then
    echo "Debug: cgroupNameRelativePath=$cgroupNameRelativePath" >&2
    echo "Debug: controllers=$controllers" >&2
    echo "Debug: cgroupName=$cgroupName" >&2
fi

# This diverges from `cgexec` where we place ourselves in a group relative to parent.
# Example:
# cgroupName = `executions/operations/29aec796-ad19-4e6b-a83b-b8b9f55d0abb`
# This process starts in the ${cgroupNameRelativePath} cgroup:
#   ├─${baseCgroup}
#   │ ├─${cgroupNameRelativePath}
#   │ │ ├─123456 /tini -- java -jar /app/build_buildfarm/buildfarm-shard-worker_deploy.jar
#   │ │ └─123457 java -jar /app/build_buildfarm/buildfarm-shard-worker_deploy.jar
#   │ └─executions
#   │   └─operations
#   │     └─29aec796-ad19-4e6b-a83b-b8b9f55d0abb
#   │        └─123458 ${@}
baseCgroup=$(dirname "${cgroupNameRelativePath}")

# More debug output
if [ "${CGEXEC_DEBUG:-1}" = "1" ]; then
    echo "Debug: baseCgroup=$baseCgroup" >&2
    echo "Debug: target_cgroup=/sys/fs/cgroup${baseCgroup}/$cgroupName" >&2
fi
# Bouncing my own PID $$ into /sys/fs/cgroup${baseCgroup}/$cgroupName"
target_cgroup="/sys/fs/cgroup${baseCgroup}/$cgroupName"

# Check if the cgroup directory exists
if [ ! -d "$target_cgroup" ]; then
    echo "Error: Cgroup directory does not exist: $target_cgroup" >&2
    echo "Available cgroups in ${baseCgroup}:" >&2
    ls -la "/sys/fs/cgroup${baseCgroup}/" 2>/dev/null || echo "Base cgroup directory not accessible: /sys/fs/cgroup${baseCgroup}/" >&2
    
    # Attempt to create the cgroup directory if parent exists
    parent_cgroup="/sys/fs/cgroup${baseCgroup}"
    if [ -d "$parent_cgroup" ] && [ -w "$parent_cgroup" ]; then
        echo "Attempting to create cgroup directory: $target_cgroup" >&2
        if mkdir -p "$target_cgroup" 2>/dev/null; then
            echo "Successfully created cgroup directory: $target_cgroup" >&2
        else
            echo "Failed to create cgroup directory: $target_cgroup" >&2
            exit 1
        fi
    else
        exit 1
    fi
fi

# Check if cgroup.procs file exists and is writable
if [ ! -f "$target_cgroup/cgroup.procs" ]; then
    echo "Error: cgroup.procs file does not exist: $target_cgroup/cgroup.procs" >&2
    exit 1
fi

if [ ! -w "$target_cgroup/cgroup.procs" ]; then
    echo "Error: No write permission to: $target_cgroup/cgroup.procs" >&2
    echo "Current user: $(id)" >&2
    echo "File permissions: $(ls -la "$target_cgroup/cgroup.procs" 2>/dev/null || echo "File not accessible")" >&2
    exit 1
fi

# Attempt to write PID to cgroup.procs with multiple strategies
write_success=false

# Method 1: Try to write current PID directly (original approach)
if echo $$ > "$target_cgroup/cgroup.procs" 2>/dev/null; then
    write_success=true
    if [ "${CGEXEC_DEBUG:-1}" = "1" ]; then
        echo "Method 1 succeeded: Moved current PID $$ to cgroup" >&2
    fi
else
    if [ "${CGEXEC_DEBUG:-1}" = "1" ]; then
        echo "Method 1 failed: Cannot write current PID $$ to cgroup.procs" >&2
    fi
fi

# Method 2: If direct write failed, try using a subshell with its own PID
if [ "$write_success" = "false" ]; then
    if [ "${CGEXEC_DEBUG:-1}" = "1" ]; then
        echo "Trying Method 2: Using subshell PID" >&2
    fi
    
    if (echo $BASHPID > "$target_cgroup/cgroup.procs" && exec "$@") 2>/dev/null; then
        # This will exit the script if successful
        exit 0
    fi
    
    if [ "${CGEXEC_DEBUG:-1}" = "1" ]; then
        echo "Method 2 failed: Cannot write subshell PID to cgroup.procs" >&2
    fi
fi

# Method 3: For container environments, try to spawn command in target cgroup directly
if [ "$write_success" = "false" ]; then
    # Check if we're in a container environment
    if [ -f /.dockerenv ] || [ -n "${KUBERNETES_SERVICE_HOST}" ] || echo "$cgroupNameRelativePath" | grep -q "kubepods\|docker\|containerd"; then
        if [ "${CGEXEC_DEBUG:-1}" = "1" ]; then
            echo "Method 3: Container environment detected, trying direct execution in target cgroup" >&2
        fi
        
        # Try to use systemd-run if available (common in containers)
        if command -v systemd-run >/dev/null 2>&1; then
            if [ "${CGEXEC_DEBUG:-1}" = "1" ]; then
                echo "Trying systemd-run to place command in cgroup" >&2
            fi
            
            # Extract the relative cgroup path for systemd-run
            cgroup_slice=$(echo "$cgroupName" | sed 's|/|-|g')
            if systemd-run --scope --slice="$cgroup_slice" "$@" 2>/dev/null; then
                exit 0
            fi
        fi
        
        # Try a different approach: fork and execute
        if [ "${CGEXEC_DEBUG:-1}" = "1" ]; then
            echo "Trying fork-and-execute approach" >&2
        fi
        
        (
            # In this subshell, try to move to the target cgroup before exec
            if echo $$ > "$target_cgroup/cgroup.procs" 2>/dev/null; then
                exec "$@"
            else
                # If we can't move this process, at least try to execute
                exec "$@"
            fi
        )
        
        # If the subshell succeeded, we're done
        exit_code=$?
        if [ $exit_code -eq 0 ]; then
            exit 0
        fi
        
        write_success="attempted"
    fi
fi

# If all methods failed, provide detailed error information and try fallback
if [ "$write_success" = "false" ]; then
    echo "Error: Failed to write PID to $target_cgroup/cgroup.procs using all available methods" >&2
    echo "This may be due to:"
    echo "  - Insufficient permissions (try running with appropriate privileges)"
    echo "  - Cgroup is frozen or in an invalid state"
    echo "  - Process already belongs to an incompatible cgroup"
    echo "  - Kubernetes/container restrictions on cgroup movement"
    echo "Current process cgroup: $cgroupNameRelativePath" >&2
    echo "Target cgroup: $target_cgroup" >&2
    
    # Additional diagnostics
    echo "Additional diagnostics:" >&2
    echo "  Current PID: $$" >&2
    echo "  Current cgroup controllers: $(cat /proc/self/cgroup)" >&2
    echo "  Target cgroup controllers: $(cat "$target_cgroup/cgroup.controllers" 2>/dev/null || echo "N/A")" >&2
    echo "  Target cgroup type: $(cat "$target_cgroup/cgroup.type" 2>/dev/null || echo "N/A")" >&2
    echo "  Target cgroup.procs permissions: $(ls -la "$target_cgroup/cgroup.procs" 2>/dev/null || echo "N/A")" >&2
    
    # Check if we can use a fallback approach
    if [ "${CGEXEC_FALLBACK:-1}" = "1" ]; then
        echo "  Attempting fallback: executing command without cgroup migration" >&2
        exec "$@"
    fi
    
    exit 1
fi

# If successful with any method, execute the command
if [ "$write_success" = "true" ]; then
    if [ "${CGEXEC_DEBUG:-1}" = "1" ]; then
        echo "Successfully moved to target cgroup, executing command: $*" >&2
    fi
    
    # In container environments, we may need to handle setgroups restrictions
    # Check if we're in a container environment
    if [ -f /.dockerenv ] || [ -n "${KUBERNETES_SERVICE_HOST}" ] || echo "$cgroupNameRelativePath" | grep -q "kubepods\|docker\|containerd"; then
        # Set environment variable to indicate we're in a restricted environment
        export CGEXEC_CONTAINER_MODE=1
        
        # Some commands may need to know about setgroups restrictions
        if [ "${CGEXEC_DEBUG:-1}" = "1" ]; then
            echo "Container environment detected - setting CGEXEC_CONTAINER_MODE=1" >&2
            echo "Note: setgroups operations may be restricted in this environment" >&2
        fi
    fi
    
    # Execute the command
    exec "$@"
fi
