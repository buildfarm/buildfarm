#!/bin/bash

set -e
# This is a drop-in replacement for cgexec, with the following differences:
#
# - It will put child processes in a cgroup relative to THIS cgroup's parent.

# Required arguments:
# -g <controllers>:<CgroupName>

# Function to display usage information
usage() {
    echo "Usage: $0 -g <value>" >&2
    exit 1
}

# Parse command line arguments
while getopts ":g:" opt; do
  case ${opt} in
    g )
      # Split the value on ":" and assign to variables
      IFS=':' read -r -a parts <<< "$OPTARG"
      controllers="${parts[0]}"
      cgroupName="${parts[1]}"
      ;;
    \? )
      usage
      ;;
  esac
done
shift $((OPTIND -1))

# Check if both variables are set, otherwise show an error message and exit
if [ -z "$controllers" ] || [ -z "$cgroupName" ]; then
    echo "Error: Both controllers and cgroupName must be specified." >&2
    usage
fi

# Get my own Cgroup from /proc/self/cgroup.
# There are three fields here, separated by ':':
# - the group ID. This is always 0 for cgroups v2.
# - the enabled controllers. This is always empty for cgroups v2.
# - the cgroup Path. This is the only part we care about.
cgroupNameRelativePath="$(cut -d':' -f3- < /proc/self/cgroup)"

# This diverges from `cgexec` where we place ourselves in a group relative to parent.
# Example:
# cgroupName = `executions/operations/29aec796-ad19-4e6b-a83b-b8b9f55d0abb`
# This process starts in the ${cgroupNameRelativePath} cgroup:
#   ├─${baseCgroup}
#   │ ├─${cgroupNameRelativePath}
#   │ │ ├─123456 /tini -- java -jar /app/build_buildfarm/buildfarm-shard-worker_deploy.jar
#   │ │ └─123457 java -jar /app/build_buildfarm/buildfarm-shard-worker_deploy.jar
#   │ └─executions
#   │   └─operations
#   │     └─29aec796-ad19-4e6b-a83b-b8b9f55d0abb
#   │        └─123458 ${@}
baseCgroup=$(dirname "${cgroupNameRelativePath}")

# Check if the target cgroup directory exists
if [[ ! -d "/sys/fs/cgroup${baseCgroup}/$cgroupName" ]]; then
    echo "ERROR: Target cgroup directory does not exist: /sys/fs/cgroup${baseCgroup}/$cgroupName" >&2
    exit 1
fi

# Check if we can write to cgroup.procs
if [[ ! -w "/sys/fs/cgroup${baseCgroup}/$cgroupName/cgroup.procs" ]]; then
    echo "ERROR: Cannot write to cgroup.procs file: /sys/fs/cgroup${baseCgroup}/$cgroupName/cgroup.procs" >&2
    echo "Current user: $(whoami), File permissions: $(ls -la "/sys/fs/cgroup${baseCgroup}/$cgroupName/cgroup.procs" 2>/dev/null || echo 'file not readable')" >&2
    exit 1
fi

# Move the process to the cgroup
if ! echo $$ > "/sys/fs/cgroup${baseCgroup}/$cgroupName/cgroup.procs" 2>/dev/null; then
    # Check if we're inside linux-sandbox by testing filesystem writability
    if [[ ! -w /sys/fs/cgroup ]]; then
        echo "WARNING: Cgroup filesystem is read-only (likely linux-sandbox environment)." >&2
        echo "Note: Process should have been moved to cgroup by parent process before sandbox started." >&2
        # Continue execution - this is expected in linux-sandbox environments
    else
        echo "ERROR: Failed to move process to cgroup. Details:" >&2
        echo "  Current user: $(whoami)" >&2
        echo "  Process ID: $$" >&2
        echo "  Target cgroup: /sys/fs/cgroup${baseCgroup}/$cgroupName/cgroup.procs" >&2
        echo "  File permissions: $(ls -la "/sys/fs/cgroup${baseCgroup}/$cgroupName/cgroup.procs" 2>/dev/null || echo 'file not readable')" >&2
        echo "  Cgroup filesystem mount: $(mount | grep cgroup || echo 'no cgroup mounts found')" >&2
        echo "  /sys/fs/cgroup permissions: $(ls -ld /sys/fs/cgroup 2>/dev/null || echo 'not readable')" >&2
        echo "  Test write to /sys/fs/cgroup: $(touch /sys/fs/cgroup/test_write 2>&1 || echo 'write failed')" >&2
        exit 1
    fi
fi

# Exec the rest of the arguments as-is
exec "$@"
